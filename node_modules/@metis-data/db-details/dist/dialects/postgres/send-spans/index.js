"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendSpansFromSlowQueryLog = exports.sendMultiSpans = exports.chuncker = exports.post = exports.makeSpan = exports.sendSpansToBackend = void 0;
const uuidv4_1 = require("uuidv4");
const sendSpansToBackend = (queriesToSend, apiKey, metisExporterUrl, logFileName, metisBackendUrl) => __awaiter(void 0, void 0, void 0, function* () {
    if (!apiKey) {
        console.debug("API Key doesnt exists");
    }
    const data = {
        "prName": logFileName,
        "prId": "no-set",
        "prUrl": "no-set"
    };
    try {
        const options = {
            method: "POST",
            headers: {
                Accept: "application/json",
                "Content-Type": "application/json",
                "Content-Length": JSON.stringify(data).length,
                "x-api-key": apiKey,
            },
        };
        yield post(`${metisBackendUrl ? metisBackendUrl : 'https://app.metisdata.io'}/api/tests/create`, JSON.stringify(data), options);
        const url = metisExporterUrl;
        yield sendMultiSpans(url, apiKey, queriesToSend);
    }
    catch (error) {
        console.error(error);
    }
});
exports.sendSpansToBackend = sendSpansToBackend;
const makeSpan = (query, queryType, plan, connection, logFileName) => __awaiter(void 0, void 0, void 0, function* () {
    const span_id = (0, uuidv4_1.uuid)();
    const traceId = (0, uuidv4_1.uuid)();
    const duration = plan && plan["Execution Time"] || 1;
    const timestamp = Date.now();
    const startDate = new Date(timestamp).toISOString();
    const endDate = new Date(timestamp + duration).toISOString();
    const vendor = "github-action";
    let hostName = vendor;
    try {
        hostName = connection.host;
    }
    catch (e) {
    }
    const resource = {
        "app.tag.pr": logFileName,
        "service.name": hostName,
        "service.version": 'or0.000000000000001%',
        "telemetry.sdk.name": vendor,
        "telemetry.sdk.version": 'or0.000000000000000000000000001%',
        "telemetry.sdk.language": vendor,
    };
    return {
        parent_id: null,
        name: queryType || "REPL",
        kind: "SpanKind.CLIENT",
        timestamp: Date.now(),
        duration: duration,
        start_time: startDate,
        end_time: endDate,
        attributes: {
            "db.name": connection === null || connection === void 0 ? void 0 : connection.database,
            "db.user": connection === null || connection === void 0 ? void 0 : connection.user,
            "db.system": 'postgres',
            "db.operation": queryType,
            "db.statement": query,
            "db.statement.metis": query + `/*traceparent=${traceId}-${span_id}*/''`,
            "db.statement.metis.plan": JSON.stringify(plan, null, 0),
            "net.peer.name": connection === null || connection === void 0 ? void 0 : connection.host,
            "net.peer.ip": connection === null || connection === void 0 ? void 0 : connection.host,
        },
        status: {
            status_code: "UNSET",
        },
        context: {
            span_id: span_id,
            trace_id: traceId,
        },
        resource,
    };
});
exports.makeSpan = makeSpan;
function post(url, data, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const parsedUrl = new URL(url);
        let http;
        if (parsedUrl.protocol === 'https:') {
            http = require('https');
        }
        else {
            http = require('http');
        }
        return new Promise((resolve, reject) => {
            const req = http.request(url, options, (res) => {
                if (res.statusCode < 200 || res.statusCode > 299) {
                    return reject({
                        statusCode: res.statusCode,
                        message: `HTTP status code ${res.statusCode}`,
                    });
                }
                const body = [];
                res.on("data", (chunk) => body.push(chunk));
                res.on("end", () => {
                    const resString = Buffer.concat(body).toString();
                    resolve(resString);
                });
            });
            req.on("error", (err) => {
                reject(err);
            });
            req.on("timeout", () => {
                req.destroy();
                reject(new Error("Request time out"));
            });
            req.write(data);
            req.end();
        });
    });
}
exports.post = post;
function* chuncker(data, limit = 200000) {
    if (!data) {
        return [];
    }
    let result = [];
    let counter = 0;
    for (const item of data) {
        counter += item.length;
        result.push(item);
        if (counter >= limit) {
            yield result;
            counter = 0;
            result = [];
        }
    }
    yield result;
}
exports.chuncker = chuncker;
function sendMultiSpans(url, apiKey, spans) {
    return __awaiter(this, void 0, void 0, function* () {
        const spansString = spans.map((d) => JSON.stringify(d, null, 0));
        const response = [];
        for (let chuckedData of chuncker(spansString)) {
            const dataString = JSON.stringify(chuckedData, null, 0);
            const options = {
                method: "POST",
                headers: {
                    Accept: "application/json",
                    "Content-Type": "application/json",
                    "Content-Length": dataString.length,
                    "x-api-key": apiKey,
                },
            };
            response.push(yield post(url, dataString, options));
        }
        return response;
    });
}
exports.sendMultiSpans = sendMultiSpans;
const sendSpansFromSlowQueryLog = (metisApikey, metisExporterUrl, slowQueryLogData, connection, logFileName, metisBackendUrl) => __awaiter(void 0, void 0, void 0, function* () {
    if (metisApikey && metisExporterUrl) {
        const spans = yield Promise.all(slowQueryLogData.map((item) => __awaiter(void 0, void 0, void 0, function* () {
            const splitted = item.message.split("plan:");
            const jsonStr = JSON.parse(splitted[1]);
            return yield (0, exports.makeSpan)(jsonStr['Query Text'], 'select', { Plan: jsonStr.Plan }, connection, logFileName);
        })));
        (0, exports.sendSpansToBackend)(spans, metisApikey, metisExporterUrl, logFileName, metisBackendUrl);
    }
});
exports.sendSpansFromSlowQueryLog = sendSpansFromSlowQueryLog;
//# sourceMappingURL=index.js.map